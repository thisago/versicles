from std/json import `$`, `%*`, `%`, `add`, newJArray, parseJson, items, `[]`,
                      `getStr`, JsonParsingError
from std/os import fileExists
from std/strformat import fmt
from std/strutils import join, toLowerAscii, replace, strip, split, AllChars,
                          Letters, Digits, `%`
import std/nre

from pkg/util/forStr import removeAccent, getEnclosedText, clean,
                              NonExtendedAlphanumeric
from pkg/bibleTools import parseBibleVerse, inOzzuuBible, `$`, parseBibleVerses,
                            enAbbr

proc genMd(
  jsonFile: string;
  outMd = "";
  defaultTranslation = "pt_yah";
  hebrewTransliterations = true;
  keepInlineVersesReferences = false;
  addVerseTranslation = false;
  crossRefsUrl = "";
  crossRefIcon = "⤭";
): bool =
  ## Generates a markdown with JSON data (parsed with `parseList`)
  result = false # no error
  if not fileExists jsonFile:
    echo fmt"The JSON file '{jsonFile}' not exists"
    return true
  try:
    let node = jsonFile.readFile.parseJson
    var md = ""
    if outMd.len > 0:
      md = """# versicles
Generated by [versicles](https://git.ozzuu.com/thisago/versicles)

All glory to **יהוה**!

## Content
""" 
    for item in node:
      var verses: seq[string]
      for v in item["verses"]:
        var
          verse = v.getStr.parseBibleVerse
          verseText = ""
        let verseUrl = verse.inOzzuuBible defaultTranslation
        if verse.translation.len == 0:
          verse.translation = defaultTranslation
        verseText = fmt"[{`$`(verse, hebrewTransliterations, addVerseTranslation, shortBook = false)}]({verseUrl})"
        if crossRefsUrl.len > 0 and verse.verses.len > 0:
          let crossRefUrl = crossRefsUrl % [
            "book", verse.book.book.enAbbr,
            "chapter", $verse.chapter,
            "verse", $verse.verses[0]
          ]
          verseText.add fmt"<sup>[[{crossRefIcon}]({crossRefUrl})]</sup>"
        verses.add verseText
      if verses.len > 0:
        md.add "#### " & verses.join(", ")
      md.add "\l"
      if keepInlineVersesReferences:
        md.add item["text"].getStr
      else:
        md.add item["textNoVerses"].getStr
      md.add "\l"
    if outMd.len > 0:
      outMd.writeFile md
    else:
      echo md
  except JsonParsingError:
    echo getCurrentExceptionMsg()
    return true

from std/unicode import nil

func removeVerses(s: string; verses: seq[string]): string =
  result = s
  for verse in verses:
    result = result.replace(verse, "")
  result = result.replace(re"\([^\w\d]*\)", "").strip

proc parseList(list, outJson: string; saveAllLines = false): bool =
  ## Converts a commented verse list into a JSON
  result = false # no error
  if not fileExists list:
    echo fmt"The list file '{list}' not exists"
    return true
  var
    node = newJArray()
    i = 0
  for l in list.readFile.split "\n":
    let line = l.strip 
    if line.len == 0: continue
    var
      verses: seq[string]
      rawVerses: seq[string]
    let enclosed = line.getEnclosedText(['(', ')'])
    if enclosed.error:
      echo fmt"Error, expected closing '(' at line {i + 1}"
      return true
    for text in enclosed.texts:
      for verse in text.strip.parseBibleVerses:
        verses.add $verse.parsed
        rawVerses.add verse.raw
    if verses.len > 0 or saveAllLines:
      node.add %*{
        "text": %line,
        "textNoVerses": %line.removeVerses rawVerses,
        "verses": %verses,
      }
    inc i
  outJson.writeFile $node

when isMainModule:
  import pkg/cligen
  dispatchMulti(
    [
      parseList,
      help = {
        "list": "Input list file path",
        "outJson": "Output JSON file path",
        "saveAllLines": "Enable all lines saving to JSON. The default is to ignore lines that haven't a verse reference"
      }
    ],
    [
      genMd,
      help = {
        "jsonFile": "Input JSON file path",
        "outMd": "Output Markdown file path",
        "defaultTranslation": "Default bible translation to use in Ozzuu Bible URLs",
        "hebrewTransliterations": "Disables the addiction of hebrew transliterated names",
      },
      short = {
        "hebrewTransliterations": 't',
      }
    ]
  )
