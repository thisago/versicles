from std/json import `$`, `%*`, `%`, `add`, newJArray, parseJson, items, `[]`,
                      `getStr`, JsonParsingError
from std/os import fileExists
from std/strformat import fmt
from std/strutils import split, strip, Whitespace, replace, join, parseInt,
                          toLowerAscii, toUpperAscii, contains
import std/nre
# import std/unicode

from pkg/util import removeAccent, getAllFirstLevelParenthesis
from pkg/bibleTools import identifyBibleBookAllLangs, en, pt,
                            hebrewTransliteration, parseBibleVerse,
                            inOzzuuBible, `$`

proc genMd(
  jsonFile: string;
  outMd = "";
  defaultTranslation = "pt_yah";
  hebrewTransliterations = true;
  keepInlineVersesReferences = false;
  addVerseTranslation = false
): bool =
  ## Generates a markdown with JSON data (parsed with `parseList`)
  result = false # no error
  if not fileExists jsonFile:
    echo fmt"The JSON file '{jsonFile}' not exists"
    return true
  try:
    let node = jsonFile.readFile.parseJson
    var md = ""
    if outMd.len > 0:
      md = """# versicles
Generated by [versicles](https://git.ozzuu.com/thisago/versicles)

All glory to **יהוה**!

## Content
"""
    for item in node:
      var verses: seq[string]
      for v in item["verses"]:
        var verse = v.getStr.parseBibleVerse
        let verseUrl = verse.inOzzuuBible defaultTranslation
        if verse.translation.len == 0:
          verse.translation = defaultTranslation
        verses.add fmt"[{`$`(verse, hebrewTransliterations, addVerseTranslation)}]({verseUrl})"
      md.add "#### " & verses.join(", ") & "\l"
      if keepInlineVersesReferences:
        md.add item["text"].getStr
      else:
        md.add item["textNoVerses"].getStr
      md.add "\l"
    if outMd.len > 0:
      outMd.writeFile md
    else:
      echo md
  except JsonParsingError:
    echo getCurrentExceptionMsg()
    return true


func removeVerses(s: string; verses: seq[string]): string =
  result = s
  for verse in verses:
    result = result.replace(verse, "")
  result = result.replace(re"\([^\w\d]*\)", "").strip

proc parseList(list, outJson: string): bool =
  ## Converts a commented verse list into a JSON
  result = false # no error
  if not fileExists list:
    echo fmt"The list file '{list}' not exists"
    return true
  var node = newJArray()
  for l in list.readFile.split "\n":
    let line = l.strip 
    if line.len == 0: continue
    var verses: seq[string]
    for parenthesis in line.getAllFirstLevelParenthesis:
      for verse in parenthesis.strip.findAll(re"[^:]+ [0-9]{1,3}:[0-9,\- ]+ ?([A-z]{2}_[A-z]+)?"):
        verses.add verse.strip.strip(chars = Whitespace + {','}) #.strip(chars = AllChars - Letters - Digits - {':', '(', ')', 'À'..'ÿ'})
    if verses.len > 0:
      node.add %*{
        "text": %line,
        "textNoVerses": %line.removeVerses verses,
        "verses": %verses,
      }
  outJson.writeFile $node

when isMainModule:
  import pkg/cligen
  dispatchMulti(
    [
      parseList,
      help = {
        "list": "Input list file path",
        "outJson": "Output JSON file path"
      }
    ],
    [
      genMd,
      help = {
        "jsonFile": "Input JSON file path",
        "outMd": "Output Markdown file path",
        "defaultTranslation": "Default bible translation to use in Ozzuu Bible URLs",
        "hebrewTransliterations": "Disables the addiction of hebrew transliterated names"
      },
      short = {
        "hebrewTransliterations": 't'
      }
    ]
  )
