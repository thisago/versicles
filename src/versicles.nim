from std/json import `$`, `%*`, `%`, `add`, newJArray, parseJson, items, `[]`,
                      `getStr`, JsonParsingError
from std/os import fileExists
from std/strformat import fmt
from std/strutils import join, toLowerAscii, replace, strip, split, AllChars,
                          Letters, Digits
import std/nre
# import std/unicode

from pkg/util import removeAccent, getAllFirstLevelParenthesis
from pkg/bibleTools import identifyBibleBookAllLangs, en, pt,
                            hebrewTransliteration, parseBibleVerse,
                            inOzzuuBible, `$`, verseRegex, ALEnglish,
                            ALPortuguese, ALDefault

proc genMd(
  jsonFile: string;
  outMd = "";
  defaultTranslation = "pt_yah";
  hebrewTransliterations = true;
  keepInlineVersesReferences = false;
  addVerseTranslation = false;
  toLang = ""
): bool =
  ## Generates a markdown with JSON data (parsed with `parseList`)
  result = false # no error
  if not fileExists jsonFile:
    echo fmt"The JSON file '{jsonFile}' not exists"
    return true
  try:
    let node = jsonFile.readFile.parseJson
    var md = ""
    if outMd.len > 0:
      md = """# versicles
Generated by [versicles](https://git.ozzuu.com/thisago/versicles)

All glory to **יהוה**!

## Content
""" 
    let translateToLang = case toLang.toLowerAscii:
                  of "en", "english": ALEnglish
                  of "pt", "portuguese": ALPortuguese
                  else: ALDefault
    for item in node:
      var verses: seq[string]
      for v in item["verses"]:
        var verse = v.getStr.parseBibleVerse
        let verseUrl = verse.inOzzuuBible defaultTranslation
        if verse.translation.len == 0:
          verse.translation = defaultTranslation
        verses.add fmt"[{`$`(verse, hebrewTransliterations, addVerseTranslation, translateToLang)}]({verseUrl})"
      if verses.len > 0:
        md.add "#### " & verses.join(", ")
      md.add "\l"
      if keepInlineVersesReferences:
        md.add item["text"].getStr
      else:
        md.add item["textNoVerses"].getStr
      md.add "\l"
    if outMd.len > 0:
      outMd.writeFile md
    else:
      echo md
  except JsonParsingError:
    echo getCurrentExceptionMsg()
    return true


func removeVerses(s: string; verses: seq[string]): string =
  result = s
  for verse in verses:
    result = result.replace(verse, "")
  result = result.replace(re"\([^\w\d]*\)", "").strip

proc parseList(list, outJson: string; saveAllLines = false): bool =
  ## Converts a commented verse list into a JSON
  result = false # no error
  if not fileExists list:
    echo fmt"The list file '{list}' not exists"
    return true
  var node = newJArray()
  for l in list.readFile.split "\n":
    let line = l.strip 
    if line.len == 0: continue
    var verses: seq[string]
    for parenthesis in line.getAllFirstLevelParenthesis:
      let verseRegexa = re"([^:]+) ([0-9]{1,3})(:[0-9,\- ]+)?[^A-z]([A-z]{2}_[A-z0-9]+)?"
      
      for verse in parenthesis.strip.findAll(verseRegexa):
        verses.add verse.strip(chars = AllChars - Letters - Digits) #.strip(chars = AllChars - Letters - Digits - {':', '(', ')', 'À'..'ÿ'})
    if verses.len > 0 or saveAllLines:
      node.add %*{
        "text": %line,
        "textNoVerses": %line.removeVerses verses,
        "verses": %verses,
      }
  outJson.writeFile $node

when isMainModule:
  import pkg/cligen
  dispatchMulti(
    [
      parseList,
      help = {
        "list": "Input list file path",
        "outJson": "Output JSON file path",
        "saveAllLines": "Enable all lines saving to JSON. The default is to ignore lines that haven't a verse reference"
      }
    ],
    [
      genMd,
      help = {
        "jsonFile": "Input JSON file path",
        "outMd": "Output Markdown file path",
        "defaultTranslation": "Default bible translation to use in Ozzuu Bible URLs",
        "hebrewTransliterations": "Disables the addiction of hebrew transliterated names",
        "toLang": "Set the language to translate",
      },
      short = {
        "hebrewTransliterations": 't',
        "toLang": 'l',
      }
    ]
  )
